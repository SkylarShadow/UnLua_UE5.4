---An Input Action is a logical representation of something the user can do, such as "Jump" or "Crouch".
---These are what your gameplay code binds to in order to listen for input state changes. For most scenarios
---your gameplay code should be listening for the "Triggered" event on an input action. This will allow
---for the most scalable and customizable input configuration because you can add different triggers
---for each key mapping in the Input Mapping Context.
---They are the conceptual equivalent to "Action" and "Axis" mapping names from the Legacy Input System.
---Note: These are instanced per player (via FInputActionInstance)
---@class UInputAction : UDataAsset
---@field public ActionDescription string @A localized descriptor of this input action
---@field public bTriggerWhenPaused boolean @Should this action be able to trigger whilst the game is paused - Replaces bExecuteWhenPaused
---@field public bConsumeInput boolean @Should this action swallow any inputs bound to it or allow them to pass through to affect lower priority bound actions?
---@field public bConsumesActionAndAxisMappings boolean @Should this Input Action consume any legacy Action and Axis key mappings? If true, then any key mapping to this input action will consume(aka block) the legacy key mapping from firing delegates.
---@field public bReserveAllMappings boolean @This action's mappings are not intended to be automatically overridden by higher priority context mappings. Users must explicitly remove the mapping first. NOTE: It is the responsibility of the author of the mapping code to enforce this!
---@field public TriggerEventsThatConsumeLegacyKeys integer @A bitmask of trigger events that, when reached, will consume any FKeys mapped to this input action.
---@field public ValueType EInputActionValueType @The type that this action returns from a GetActionValue query or action event
---@field public AccumulationBehavior EInputActionAccumulationBehavior @This defines how the value of this input action will be calcuated in the case that there are multiple key mappings to the same input action. When TakeHighestAbsoluteValue is selected, then the key mapping with the highest absolutle value will be utilized. (Default) When Cumulative is selected, then each key mapping will be added together to get the key value.
---@field public Triggers TArray<UInputTrigger> @Trigger qualifiers. If any trigger qualifiers exist the action will not trigger unless: At least one Explicit trigger in this list has been met. All Implicit triggers in this list are met.
---@field public Modifiers TArray<UInputModifier> @Modifiers are applied to the final action value. These are applied sequentially in array order. They are applied on top of any FEnhancedActionKeyMapping modifiers that drove the initial input Note: Modifiers defined in the Input Action asset will be applied AFTER any modifiers defined in individual key mappings in the Input Mapping Context asset.
---@field protected PlayerMappableKeySettings UPlayerMappableKeySettings @Holds setting information about this Action Input for setting screen and save purposes.
local UInputAction = {}

