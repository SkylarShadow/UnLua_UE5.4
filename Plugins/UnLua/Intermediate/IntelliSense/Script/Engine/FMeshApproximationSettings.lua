---@class FMeshApproximationSettings
---@field public OutputType EMeshApproximationType @Type of output from mesh approximation process
---@field public ApproximationAccuracy number @Approximation Accuracy in Meters, will determine (eg) voxel resolution
---@field public ClampVoxelDimension integer @Maximum allowable voxel count along main directions. This is a limit on ApproximationAccuracy. Max of 1290 (1290^3 is the last integer < 2^31, using a bigger number results in failures in TArray code & probably elsewhere)
---@field public bAttemptAutoThickening boolean @if enabled, we will attempt to auto-thicken thin parts or flat sheets
---@field public TargetMinThicknessMultiplier number @Multiplier on Approximation Accuracy used for auto-thickening
---@field public bIgnoreTinyParts boolean @If enabled, tiny parts will be excluded from the mesh merging, which can improve performance
---@field public TinyPartSizeMultiplier number @Multiplier on Approximation Accuracy used to define tiny-part threshold, using maximum bounding-box dimension
---@field public BaseCapping EMeshApproximationBaseCappingType @Optional methods to attempt to close off the bottom of open meshes
---@field public WindingThreshold number @Winding Threshold controls hole filling at open mesh borders. Smaller value means "more/rounder" filling
---@field public bFillGaps boolean @If true, topological expand/contract is used to try to fill small gaps between objects.
---@field public GapDistance number @Distance in Meters to expand/contract to fill gaps
---@field public OcclusionMethod EOccludedGeometryFilteringPolicy @Type of hidden geometry removal to apply
---@field public bOccludeFromBottom boolean @If true, then the OcclusionMethod computation is configured to try to consider downward-facing "bottom" geometry as occluded
---@field public SimplifyMethod EMeshApproximationSimplificationPolicy @Mesh Simplification criteria
---@field public TargetTriCount integer @Target triangle count for Mesh Simplification, for SimplifyMethods that use a Count
---@field public TrianglesPerM number @Approximate Number of triangles per Square Meter, for SimplifyMethods that use such a constraint
---@field public GeometricDeviation number @Allowable Geometric Deviation in Meters when SimplifyMethod incorporates a Geometric Tolerance
---@field public GroundClipping EMeshApproximationGroundPlaneClippingPolicy @Configure how the final mesh should be clipped with a ground plane, if desired
---@field public GroundClippingZHeight number @Z-Height for the ground clipping plane, if enabled
---@field public bEstimateHardNormals boolean @If true, normal angle will be used to estimate hard normals
---@field public HardNormalAngle number
---@field public UVGenerationMethod EMeshApproximationUVGenerationPolicy @Mesh UV Generation Settings
---@field public InitialPatchCount integer @Number of initial patches mesh will be split into before computing island merging
---@field public CurvatureAlignment number @This parameter controls alignment of the initial patches to creases in the mesh
---@field public MergingThreshold number @Distortion/Stretching Threshold for island merging - larger values increase the allowable UV stretching
---@field public MaxAngleDeviation number @UV islands will not be merged if their average face normals deviate by larger than this amount
---@field public bGenerateNaniteEnabledMesh boolean @Whether to generate a nanite-enabled mesh
---@field public NaniteFallbackTarget ENaniteFallbackTarget @Which heuristic to use when generating the Nanite fallback mesh.
---@field public NaniteFallbackPercentTriangles number @Percentage of triangles to keep from source Nanite mesh for fallback. 1.0 = no reduction, 0.0 = no triangles.
---@field public NaniteFallbackRelativeError number @Reduce Nanite fallback mesh until at least this amount of error is reached relative to size of the mesh.
---@field public bSupportRayTracing boolean @Whether ray tracing will be supported on this mesh. Disable this to save memory if the generated mesh will only be rendered in the distance.
---@field public bAllowDistanceField boolean @Whether to allow distance field to be computed for this mesh. Disable this to save memory if the generated mesh will only be rendered in the distance.
---@field public MultiSamplingAA integer @If Value is > 1, Multisample output baked textures by this amount in each direction (eg 4 == 16x supersampling)
---@field public RenderCaptureResolution integer @If Value is zero, use MaterialSettings resolution, otherwise override the render capture resolution
---@field public MaterialSettings FMaterialProxySettings @Material generation settings
---@field public CaptureFieldOfView number
---@field public NearPlaneDist number
---@field public bUseRenderLODMeshes boolean @If true, LOD0 Render Meshes (or Nanite Fallback meshes) are used instead of Source Mesh data. This can significantly reduce computation time and memory usage, but potentially at the cost of lower quality output.
---@field public bEnableSimplifyPrePass boolean @If true, a faster mesh simplfication strategy will be used. This can significantly reduce computation time and memory usage, but potentially at the cost of lower quality output.
---@field public bEnableParallelBaking boolean @If false, texture capture and baking will be done serially after mesh generation, rather than in parallel when possible. This will reduce the maximum memory requirements of the process.
---@field public bPrintDebugMessages boolean @If true, print out debugging messages
---@field public bEmitFullDebugMesh boolean @If true, write the full mesh triangle set (ie flattened, non-instanced) used for mesh generation. Warning: this asset may be extremely large!!
local FMeshApproximationSettings = {}
